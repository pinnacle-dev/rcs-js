// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import * as errors from "../../../../../../errors/index.js";
import * as Pinnacle from "../../../../../index.js";

export declare namespace Rcs {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class Rcs {
    protected readonly _options: Rcs.Options;

    constructor(_options: Rcs.Options) {
        this._options = _options;
    }

    /**
     * Generate campaign details based off existing campaign and the brand it's connected to.
     *
     * @param {Pinnacle.AutofillCampaignParams} request
     * @param {Rcs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Pinnacle.BadRequestError}
     * @throws {@link Pinnacle.UnauthorizedError}
     * @throws {@link Pinnacle.InternalServerError}
     *
     * @example
     *     await client.campaigns.rcs.autofill({
     *         additionalInfo: "Please autofill missing campaign fields using my brand profile",
     *         campaignId: "dlc_1234567890"
     *     })
     */
    public autofill(
        request: Pinnacle.AutofillCampaignParams,
        requestOptions?: Rcs.RequestOptions,
    ): core.HttpResponsePromise<Pinnacle.campaigns.RcsAutofillResponse> {
        return core.HttpResponsePromise.fromPromise(this.__autofill(request, requestOptions));
    }

    private async __autofill(
        request: Pinnacle.AutofillCampaignParams,
        requestOptions?: Rcs.RequestOptions,
    ): Promise<core.WithRawResponse<Pinnacle.campaigns.RcsAutofillResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PinnacleEnvironment.Default,
                "campaigns/rcs/autofill",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Pinnacle.campaigns.RcsAutofillResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Pinnacle.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Pinnacle.UnauthorizedError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Pinnacle.InternalServerError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PinnacleError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PinnacleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PinnacleTimeoutError("Timeout exceeded when calling POST /campaigns/rcs/autofill.");
            case "unknown":
                throw new errors.PinnacleError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve RCS campaign.
     *
     * @param {string} campaignId - Unique identifier of the RCS campaign. Must begin with the prefix `rcs_`.
     * @param {Rcs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Pinnacle.BadRequestError}
     * @throws {@link Pinnacle.UnauthorizedError}
     * @throws {@link Pinnacle.NotFoundError}
     * @throws {@link Pinnacle.InternalServerError}
     *
     * @example
     *     await client.campaigns.rcs.get("rcs_1234567890")
     */
    public get(
        campaignId: string,
        requestOptions?: Rcs.RequestOptions,
    ): core.HttpResponsePromise<Pinnacle.ExtendedRcsCampaign> {
        return core.HttpResponsePromise.fromPromise(this.__get(campaignId, requestOptions));
    }

    private async __get(
        campaignId: string,
        requestOptions?: Rcs.RequestOptions,
    ): Promise<core.WithRawResponse<Pinnacle.ExtendedRcsCampaign>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PinnacleEnvironment.Default,
                `campaigns/rcs/${core.url.encodePathParam(campaignId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Pinnacle.ExtendedRcsCampaign, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Pinnacle.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Pinnacle.UnauthorizedError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Pinnacle.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Pinnacle.InternalServerError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PinnacleError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PinnacleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PinnacleTimeoutError("Timeout exceeded when calling GET /campaigns/rcs/{campaignId}.");
            case "unknown":
                throw new errors.PinnacleError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Submit your RCS campaign for approval and activation with carriers.
     *
     * @param {string} campaignId - Unique identifier of the RCS campaign to retrieve. Must begin with the prefix `rcs_`.
     * @param {Rcs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Pinnacle.BadRequestError}
     * @throws {@link Pinnacle.UnauthorizedError}
     * @throws {@link Pinnacle.PaymentRequiredError}
     * @throws {@link Pinnacle.NotFoundError}
     * @throws {@link Pinnacle.InternalServerError}
     *
     * @example
     *     await client.campaigns.rcs.submit("rcs_1234567890")
     */
    public submit(
        campaignId: string,
        requestOptions?: Rcs.RequestOptions,
    ): core.HttpResponsePromise<Pinnacle.CampaignSubmissionResult> {
        return core.HttpResponsePromise.fromPromise(this.__submit(campaignId, requestOptions));
    }

    private async __submit(
        campaignId: string,
        requestOptions?: Rcs.RequestOptions,
    ): Promise<core.WithRawResponse<Pinnacle.CampaignSubmissionResult>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PinnacleEnvironment.Default,
                `campaigns/rcs/submit/${core.url.encodePathParam(campaignId)}`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Pinnacle.CampaignSubmissionResult, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Pinnacle.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Pinnacle.UnauthorizedError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                case 402:
                    throw new Pinnacle.PaymentRequiredError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Pinnacle.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Pinnacle.InternalServerError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PinnacleError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PinnacleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PinnacleTimeoutError(
                    "Timeout exceeded when calling POST /campaigns/rcs/submit/{campaignId}.",
                );
            case "unknown":
                throw new errors.PinnacleError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new RCS campaign or update an existing one.
     *
     * <Note>
     * **To create a new campaign:** Omit `campaignId` — one will be generated automatically.
     *
     * **Before you start:** Create a [brand](/api-reference/brands/upsert) first — you'll need its `id` for the [`brand`](#request.body.brand) field.
     *
     * All fields are **required** unless specified otherwise, and will be validated when [submitted](/api-reference/campaigns/rcs/submit).
     * </Note>
     *
     * @param {Pinnacle.campaigns.UpsertRcsCampaignParams} request
     * @param {Rcs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Pinnacle.BadRequestError}
     * @throws {@link Pinnacle.UnauthorizedError}
     * @throws {@link Pinnacle.NotFoundError}
     * @throws {@link Pinnacle.InternalServerError}
     *
     * @example
     *     await client.campaigns.rcs.upsert({
     *         agent: {
     *             color: "#000000",
     *             description: "Experience the power of RCS messaging with interactive demos. Test rich features like carousels, suggested replies, and media sharing. Get started with our developer-friendly APIs.",
     *             emails: [{
     *                     email: "founders@trypinnacle.app",
     *                     label: "Email Us"
     *                 }],
     *             heroUrl: "https://pncl.to/D6pDSqGxqgfbCfQmw4gXdnlHu4uSB4",
     *             iconUrl: "https://pncl.to/mq_tdIDenRb5eYpJiM8-3THCaUBrZP",
     *             name: "Pinnacle - RCS Demo",
     *             phones: [{
     *                     label: "Contact us directly",
     *                     phone: "+14154467821"
     *                 }],
     *             websites: [{
     *                     label: "Get started with Pinnacle",
     *                     url: "https://www.trypinnacle.app/"
     *                 }]
     *         },
     *         brand: "b_1234567890",
     *         campaignId: "rcs_1234567890",
     *         expectedAgentResponses: ["Here are the things I can help you with.", "I can assist you with booking an appointment, or you may choose to book manually.", "Here are the available times to connect with a representative tomorrow.", "Your appointment has been scheduled."],
     *         links: {
     *             privacyPolicy: "https://www.trypinnacle.app/privacy",
     *             termsOfService: "https://www.trypinnacle.app/terms"
     *         },
     *         useCase: {
     *             behavior: "Pinnacle is a developer-focused RCS assistant that helps teams design, test, and optimize rich messaging experiences across SMS, MMS, and RCS. The agent acts as both an \u201Conboarding guide\u201D for new customers and a \u201Cbest-practices coach\u201D for existing teams exploring higher-value RCS workflows like rich cards, carousels, and suggested actions.<br>\nThe agent delivers a mix of operational updates and educational content (2\u20136 messages/month). Content includes important platform notices (e.g., deliverability or throughput changes), implementation tips with sample RCS templates, and personalized recommendations on how to upgrade existing SMS campaigns into richer, higher-converting RCS conversations.\n",
     *             value: "OTHER"
     *         },
     *         optInTermsAndConditions: "We ensure consent through an explicit opt-in process that follows 10DLC best practices.Users must agree to receive messages from Pinnacle before the agent sends them any messages.<br>\nUsers agree to these messages by signing an opt-in paper form that they can be found online at https://www.pinnacle.sh/opt-in. We only send messages once users have filled out the form and submitted it to us via email or through the dashboard.\n",
     *         messagingType: "MULTI_USE",
     *         carrierDescription: "Demonstrate the power of RCS to medium and large companies already sending massive SMS/MMS volumes through our platform. These clients send conversational messages in industries such as commerce, appointments, and customer support.",
     *         keywords: {
     *             HELP: {
     *                 message: "Email founders@trypinnacle.app for support.",
     *                 keywords: ["HELP", "SUPPORT"]
     *             },
     *             OPT_IN: {
     *                 message: "Welcome back to Pinnacle!<br>\n\uD83D\uDD14 You're now subscribed to Pinnacle - RCS Demo and will continue receiving important updates and news. Feel free to contact this us at any time for help.<br>\n\nReply STOP to opt out and HELP for support. Message & rates may apply.\n",
     *                 keywords: ["START", "SUBSCRIBE"]
     *             },
     *             OPT_OUT: {
     *                 message: "You've been unsubscribed from Pinnacle - RCS Demo and will no longer receive notifications. If you ever change your mind, reply START or SUBSCRIBE to rejoin anytime.",
     *                 keywords: ["STOP", "UNSUBSCRIBE", "END"]
     *             }
     *         },
     *         traffic: {
     *             monthlyWebsite: 10000,
     *             monthlyRcsEstimate: 10000
     *         },
     *         agentTriggers: "The agent sends the first message when the user subscribes to Pinnacle. Messages are based on user actions such as pressing suggestion buttons. External triggers such as reminders can be setup by users in advance for a later time.",
     *         interactionDescription: "The agent's primary interaction will be customer service \u2014 helping users with questions, troubleshooting issues, and providing quick assistance through chat. Other interactions include appointment management and sending notifications to the user.",
     *         isConversational: true,
     *         ctaLanguage: "By checking this box and submitting this form, you consent to receive transactional text messages for support, appointment, and reminder messages from Pinnacle Software Development Inc. Reply STOP to opt out. Reply HELP for help. Standard message and data rates may apply. Message frequency may vary. View our Terms and Conditions at https://www.pinnacle.sh/terms. View our Privacy Policy at https://www.pinnacle.sh/privacy.",
     *         demoTrigger: "Text \"START\" to trigger the flow."
     *     })
     */
    public upsert(
        request: Pinnacle.campaigns.UpsertRcsCampaignParams = {},
        requestOptions?: Rcs.RequestOptions,
    ): core.HttpResponsePromise<Pinnacle.ExtendedRcsCampaign> {
        return core.HttpResponsePromise.fromPromise(this.__upsert(request, requestOptions));
    }

    private async __upsert(
        request: Pinnacle.campaigns.UpsertRcsCampaignParams = {},
        requestOptions?: Rcs.RequestOptions,
    ): Promise<core.WithRawResponse<Pinnacle.ExtendedRcsCampaign>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PinnacleEnvironment.Default,
                "campaigns/rcs",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Pinnacle.ExtendedRcsCampaign, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Pinnacle.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Pinnacle.UnauthorizedError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Pinnacle.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Pinnacle.InternalServerError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PinnacleError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PinnacleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PinnacleTimeoutError("Timeout exceeded when calling POST /campaigns/rcs.");
            case "unknown":
                throw new errors.PinnacleError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Validate your RCS campaign configuration against carrier requirements and compliance rules.
     *
     * @param {Pinnacle.ValidateCampaignParams} request
     * @param {Rcs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Pinnacle.BadRequestError}
     * @throws {@link Pinnacle.UnauthorizedError}
     * @throws {@link Pinnacle.InternalServerError}
     *
     * @example
     *     await client.campaigns.rcs.validate({
     *         additionalInfo: "Please validate this DLC campaign for 10DLC compliance",
     *         campaignId: "dlc_1234567890"
     *     })
     */
    public validate(
        request: Pinnacle.ValidateCampaignParams,
        requestOptions?: Rcs.RequestOptions,
    ): core.HttpResponsePromise<Pinnacle.CampaignValidationResult> {
        return core.HttpResponsePromise.fromPromise(this.__validate(request, requestOptions));
    }

    private async __validate(
        request: Pinnacle.ValidateCampaignParams,
        requestOptions?: Rcs.RequestOptions,
    ): Promise<core.WithRawResponse<Pinnacle.CampaignValidationResult>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PinnacleEnvironment.Default,
                "campaigns/rcs/validate",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Pinnacle.CampaignValidationResult, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Pinnacle.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Pinnacle.UnauthorizedError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Pinnacle.InternalServerError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PinnacleError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PinnacleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PinnacleTimeoutError("Timeout exceeded when calling POST /campaigns/rcs/validate.");
            case "unknown":
                throw new errors.PinnacleError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | undefined>> {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "PINNACLE-API-KEY": apiKeyValue };
    }
}
