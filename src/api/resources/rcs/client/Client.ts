// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as environments from "../../../../environments.js";
import * as errors from "../../../../errors/index.js";
import * as Pinnacle from "../../../index.js";

export declare namespace Rcs {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class Rcs {
    protected readonly _options: Rcs.Options;

    constructor(_options: Rcs.Options = {}) {
        this._options = _options;
    }

    /**
     * Check RCS capabilities for one or more phone numbers.
     *
     * This endpoint allows you to verify which RCS features (cards, buttons, etc.) are supported
     * on specific phone numbers before sending RCS messages to them.
     *
     * @param {Pinnacle.RcsCapabilitiesQuery} request
     * @param {Rcs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Pinnacle.BadRequestError}
     * @throws {@link Pinnacle.UnauthorizedError}
     * @throws {@link Pinnacle.InternalServerError}
     * @throws {@link Pinnacle.NotImplementedError}
     *
     * @example
     *     await client.rcs.getCapabilities({
     *         phoneNumbers: ["+12345678901", "+19876543210"]
     *     })
     */
    public getCapabilities(
        request: Pinnacle.RcsCapabilitiesQuery,
        requestOptions?: Rcs.RequestOptions,
    ): core.HttpResponsePromise<Pinnacle.RcsCapabilitiesResult> {
        return core.HttpResponsePromise.fromPromise(this.__getCapabilities(request, requestOptions));
    }

    private async __getCapabilities(
        request: Pinnacle.RcsCapabilitiesQuery,
        requestOptions?: Rcs.RequestOptions,
    ): Promise<core.WithRawResponse<Pinnacle.RcsCapabilitiesResult>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PinnacleEnvironment.Default,
                "rcs/capabilities",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Pinnacle.RcsCapabilitiesResult, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Pinnacle.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Pinnacle.UnauthorizedError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Pinnacle.InternalServerError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                case 501:
                    throw new Pinnacle.NotImplementedError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PinnacleError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PinnacleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PinnacleTimeoutError("Timeout exceeded when calling POST /rcs/capabilities.");
            case "unknown":
                throw new errors.PinnacleError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Whitelist a phone number for testing with your test RCS agent.
     *
     * ## Overview
     * During development and testing, RCS agents can only send messages to whitelisted phone numbers.
     * Use this endpoint to whitelist specific phone numbers to send and receive messages from the test agent.
     *
     * ## Verification Process
     * After whitelisting a number, you'll need to complete verification:
     *
     * 1. Check the test device for message from "RBM Tester Management"
     * 2. Click the "Make me a tester" button
     * 3. Enter the separate 4-digit verification SMS code in the Pinnacle dashboard at:
     *    ```
     *    https://app.pinnacle.sh/dashboard/brands/{brandId}?campaignId={campaignId}&campaignType=RCS
     *    ```
     *
     *  > **⚠️ Important: Re-whitelisting Numbers**
     * >
     * > If you whitelist a number that's already whitelisted, you'll receive a new message from "RBM Tester Management". **You must click the "Make me a tester" button again to continue sending and receiving messages.**
     *
     * > **Important Notes**
     * >
     * > - **Verification required:** Messages cannot be sent nor received until you have clicked the "Make me a tester" button on the test device.
     * > - **Testing only:** This is only required for test agents. Production agents can message any RCS-enabled number.
     * > - **Network limitations:** Whitelisting may be temporarily unavailable for some carriers but are usually restored shortly.
     *
     * @param {Pinnacle.RcsWhitelistRequest} request
     * @param {Rcs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Pinnacle.BadRequestError}
     * @throws {@link Pinnacle.UnauthorizedError}
     * @throws {@link Pinnacle.NotFoundError}
     * @throws {@link Pinnacle.InternalServerError}
     * @throws {@link Pinnacle.NotImplementedError}
     *
     * @example
     *     await client.rcs.whitelist({
     *         agentId: "agent_XXXXXXXXXXXX",
     *         phoneNumber: "+12345678901"
     *     })
     */
    public whitelist(
        request: Pinnacle.RcsWhitelistRequest,
        requestOptions?: Rcs.RequestOptions,
    ): core.HttpResponsePromise<Pinnacle.RcsWhitelistResponse> {
        return core.HttpResponsePromise.fromPromise(this.__whitelist(request, requestOptions));
    }

    private async __whitelist(
        request: Pinnacle.RcsWhitelistRequest,
        requestOptions?: Rcs.RequestOptions,
    ): Promise<core.WithRawResponse<Pinnacle.RcsWhitelistResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PinnacleEnvironment.Default,
                "rcs/whitelist",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Pinnacle.RcsWhitelistResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Pinnacle.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Pinnacle.UnauthorizedError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Pinnacle.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Pinnacle.InternalServerError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                case 501:
                    throw new Pinnacle.NotImplementedError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PinnacleError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PinnacleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PinnacleTimeoutError("Timeout exceeded when calling POST /rcs/whitelist.");
            case "unknown":
                throw new errors.PinnacleError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Generate a link for initiating an RCS conversation with your agent.
     *
     * Users can click these links to start conversations with your RCS agent directly
     * from websites, emails, or other applications.
     *
     * @param {Pinnacle.RcsLinkRequest} request
     * @param {Rcs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Pinnacle.BadRequestError}
     * @throws {@link Pinnacle.UnauthorizedError}
     * @throws {@link Pinnacle.NotFoundError}
     * @throws {@link Pinnacle.InternalServerError}
     * @throws {@link Pinnacle.NotImplementedError}
     *
     * @example
     *     await client.rcs.getLink({
     *         agentId: "agent_XXXXXXXXXXXX",
     *         testMode: false,
     *         phoneNumber: "+12345678901",
     *         body: "Hello, I need help with my order"
     *     })
     */
    public getLink(
        request: Pinnacle.RcsLinkRequest,
        requestOptions?: Rcs.RequestOptions,
    ): core.HttpResponsePromise<Pinnacle.RcsLinkResult> {
        return core.HttpResponsePromise.fromPromise(this.__getLink(request, requestOptions));
    }

    private async __getLink(
        request: Pinnacle.RcsLinkRequest,
        requestOptions?: Rcs.RequestOptions,
    ): Promise<core.WithRawResponse<Pinnacle.RcsLinkResult>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PinnacleEnvironment.Default,
                "rcs/link",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Pinnacle.RcsLinkResult, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Pinnacle.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Pinnacle.UnauthorizedError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Pinnacle.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Pinnacle.InternalServerError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                case 501:
                    throw new Pinnacle.NotImplementedError(
                        _response.error.body as Pinnacle.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PinnacleError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PinnacleError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PinnacleTimeoutError("Timeout exceeded when calling POST /rcs/link.");
            case "unknown":
                throw new errors.PinnacleError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | undefined>> {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "PINNACLE-API-KEY": apiKeyValue };
    }
}
